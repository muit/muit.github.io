<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Lately, I have been playing around with the implementation of custom allocators and arenas to replace native allocations on my C++ projects.
Wow! Stop right there, Miguel. This line already deserves some introductions! Let&amp;rsquo;s talk about allocators.
Crash course on allocations To keep this brief, I will assume that we have some experience with C++ and heap allocation (malloc and new).
An allocation is when we request a pointer to a block of memory of a specified size."><meta name=keywords content="muitxer,homepage,blog,portfolio,unreal engine,C++,Rust,piperift"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://muit.xyz/drafts/posts/memory-introduction-to-allocators-and-arenas/><title>Introduction to allocators and arenas :: Miguel Fernandez Arce</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/drafts/main.css><meta itemprop=name content="Introduction to allocators and arenas"><meta itemprop=description content="Lately, I have been playing around with the implementation of custom allocators and arenas to replace native allocations on my C++ projects.
Wow! Stop right there, Miguel. This line already deserves some introductions! Let&rsquo;s talk about allocators.
Crash course on allocations To keep this brief, I will assume that we have some experience with C++ and heap allocation (malloc and new).
An allocation is when we request a pointer to a block of memory of a specified size."><meta itemprop=datePublished content="2021-03-30T00:00:00+00:00"><meta itemprop=dateModified content="2021-03-30T00:00:00+00:00"><meta itemprop=wordCount content="915"><meta itemprop=image content="https://muit.xyz/drafts"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://muit.xyz/drafts"><meta name=twitter:title content="Introduction to allocators and arenas"><meta name=twitter:description content="Lately, I have been playing around with the implementation of custom allocators and arenas to replace native allocations on my C++ projects.
Wow! Stop right there, Miguel. This line already deserves some introductions! Let&rsquo;s talk about allocators.
Crash course on allocations To keep this brief, I will assume that we have some experience with C++ and heap allocation (malloc and new).
An allocation is when we request a pointer to a block of memory of a specified size."><meta property="og:title" content="Introduction to allocators and arenas"><meta property="og:description" content="Lately, I have been playing around with the implementation of custom allocators and arenas to replace native allocations on my C++ projects.
Wow! Stop right there, Miguel. This line already deserves some introductions! Let&rsquo;s talk about allocators.
Crash course on allocations To keep this brief, I will assume that we have some experience with C++ and heap allocation (malloc and new).
An allocation is when we request a pointer to a block of memory of a specified size."><meta property="og:type" content="article"><meta property="og:url" content="https://muit.xyz/drafts/posts/memory-introduction-to-allocators-and-arenas/"><meta property="og:image" content="https://muit.xyz/drafts"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2021-03-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-30T00:00:00+00:00"><meta property="og:see_also" content="https://muit.xyz/drafts/posts/memory-implementing-a-general-arena/"><meta property="article:published_time" content="2021-03-30 00:00:00 +0000 UTC"><script src=https://identity.netlify.com/v1/netlify-identity-widget.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>Miguel Fernandez Arce</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/drafts/pages/about>About</a></li><li><a href=/drafts/posts>Posts</a></li><li><a href=https://github.com/muit>GitHub</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://muit.xyz/drafts/posts/memory-introduction-to-allocators-and-arenas/>Introduction to allocators and arenas</a></h2><figure class=post-cover><img src=https://muit.xyz/Assets/Img/Covers/storage.png alt="Introduction to allocators and arenas"></figure><div class=post-content><p>Lately, I have been playing around with the implementation of custom allocators and arenas to replace native allocations on my C++ projects.</p><p>Wow! Stop right there, Miguel. This line already deserves some introductions!
Let&rsquo;s talk about allocators.</p><h2 id=crash-course-on-allocations>Crash course on allocations</h2><p>To keep this brief, I will assume that we have some experience with C++ and heap allocation (<code>malloc</code> and <code>new</code>).</p><p>An <strong>allocation</strong> is when we request a pointer to a block of memory of a specified size.
When we use <code>malloc</code> or <code>new</code> we are getting this block of memory from the heap.</p><p>When we <strong>deallocate</strong> a pointer (calling <code>free</code> or <code>delete</code>) its block of memory becomes once again available and no longer needed by us.</p><h2 id=what-are-allocators-and-arenas>What are Allocators and Arenas</h2><p>The definition of an allocator is somewhat flexible. It involves the encapsulation of allocation and deallocation of memory.</p><p>The allocators provided by the STD (the C++ standard library) are templated objects bound to a type.
For example, <code>std::vector</code> can have different allocators.</p><p>In game development, we also use allocators as global memory managers.
Using them, we can optimize allocations for specific parts of a game engine.
For example, we can have an allocator that contains one render frame of data and gets cleared when a new frame starts.</p><p>But&mldr; Isn&rsquo;t it confusing to call everything an allocator?
I believe it is, and I don&rsquo;t seem to be the only one because some engines call the global memory allocators <em>arenas</em>.</p><p>Therefore, let&rsquo;s stick with the following terminology:</p><blockquote><p><strong>Allocators</strong> are objects that encapsulate allocation and deallocation of memory</p></blockquote><blockquote><p><strong>Arenas</strong> are independent (often global) allocators</p></blockquote><blockquote><p><strong>Container Allocators</strong> are stateful allocators that manage the memory used by a container</p></blockquote><h2 id=why-are-they-necessary>Why are they necessary?</h2><p>Native allocation needs to work in all scenarios.
It behaves like a general-purpose arena, meaning it can&rsquo;t have limitations, and it must be good enough at doing everything.
All this, while lacking any context about our particular use case.</p><p>Knowing this, I can think of three performance benefits from allocators:
<strong>Allocation/free cost</strong>, <strong>memory locality</strong> and <strong>fragmentation</strong>.</p><blockquote><p><strong>Allocation/Free Cost</strong></p><p><code>malloc</code> acts as the intermediary between the program and the OS.
For example, sometimes it will need to request more memory from the Kernel, and that is very slow</p></blockquote><blockquote><p><strong>Memory Locality</strong></p><p>Very briefly speaking, modern CPUs have cache-lines, caches and RAM.
Since data is retrieved in blocks into the caches, if the data we need is cohesive, it&rsquo;s much more likely that it will be already cached.
Accessing RAM instead of CPU cache can be hundreds of times slower.</p><p>Since <code>malloc</code> and <code>new</code> don&rsquo;t have context about our memory use-cases, the pointers allocated can be anywhere.
However, allocators can give us much better memory locality.</p></blockquote><blockquote><p><strong>Fragmentation</strong>
<img src=/Assets/Img/fragmentation.png alt=Fragmentation>
Fragmentation occurs when we have allocated and freed multiple times leaving gaps that are not big enough to fit new allocations.</p><p>This means we will need to request more memory. Some allocator algorithms don&rsquo;t have fragmentation at all. Others have the information to reduce it further than <code>malloc</code> can.</p></blockquote><p>From a technical design standpoint, we will also simplify code, <em>visualizing</em> where memory is held at all times and under which rules.
We can use the arena that fits our problem and change it if needed.</p><h2 id=types-of-allocators>Types of Allocators</h2><p>There are many types of allocators based on their algorithms.
Each of them brings benefits as well as limitations.</p><p>There is no way I could explain all of them, but let me give you a quick rundown of the simplest ones.</p><h3 id=linear>Linear</h3><p><img src=/Assets/Img/linear-allocator.png alt="Linear Allocator"></p><p>A <strong>Linear allocator</strong> reserves a big block of memory and then moves an offset to the next available position when allocating.
Since it doesn&rsquo;t keep track of previous allocations, a linear allocator <strong>can&rsquo;t be freed</strong>.</p><p>This algorithm is by far the most performant due to its simplicity.
But it also has the most limitations, so its use in the real world is very specific.</p><h3 id=stack>Stack</h3><p><img src=/Assets/Img/stack-allocator.png alt="Stack Allocator">
<strong>Stack</strong> is one step more advanced than Linear. It knows the size of all allocations, allowing us to free the <strong>last</strong> allocation.</p><h3 id=pool>Pool</h3><p><img src=/Assets/Img/pool-allocator.png alt="Pool Allocator"></p><p>A <strong>Pool</strong> <em>allocator</em> contains a list of same size slots. All allocations must be smaller than one slot.</p><p>To track which slots are available, we can use a bitset.
They are very performant and compact containers where 1 bit represents one occupied slot.</p><p>Some implementations keep track of allocations using a linked list.
However, this means we need to iterate over the entire memory block. It also introduces 8 extra bytes for each allocation.</p><h3 id=general>General</h3><p>A <strong>general</strong> allocator can be used for all use-cases and doesn&rsquo;t have any big limitation.
I will soon publish how I implemented a general arena that is up to <strong>130x</strong> faster than <code>malloc</code>.</p><h3 id=many-more>Many more!</h3><p>Those were not all allocators that exist. There are many more.
Each algorithm has advantages and disadvantages, and it&rsquo;s up to us to choose the best one for the job.</p><p>Some I didn&rsquo;t mention:</p><ul><li><a href=https://en.wikipedia.org/wiki/Buddy_memory_allocation>Buddy allocator</a></li><li><a href=https://www.geeksforgeeks.org/operating-system-allocating-kernel-memory-buddy-system-slab-system/>Slab allocator</a></li></ul><h2 id=native-allocation-replacements>Native allocation replacements</h2><p>Some libraries just provide an extra layer between us and <code>malloc</code> but not necessarily using the concepts we described before.
They still lack context about our use-case and need to solve every problem just like <code>malloc</code>. However, they manage to be considerably faster than the default solution.</p><p>Depending on what you do, these libraries might be enough. However, setup is not always as intuitive and straight-forward as it should be.</p><p>One example is
<a href=https://github.com/microsoft/mimalloc target=_blank>microsoft/mimalloc</a>.</p><h2 id=resources>Resources</h2><ul><li><a href=https://gamasutra.com/blogs/MichaelKissner/20151104/258271/Writing_a_Game_Engine_from_Scratch__Part_2_Memory.php>Writing a Game Engine from Scratch - Part 2: Memory</a></li><li><a href="https://youtu.be/rX0ItVEVjHc?t=1830">CppCon 2014: Mike Acton &ldquo;Data-Oriented Design and C++&rdquo;</a></li><li><a href=https://www.gamasutra.com/blogs/ThomasYoung/20141002/226898/Custom_Vector_Allocation.php>Custom Vector Allocation</a></li><li>Some allocator implementation examples:
<a href=https://github.com/mtrebi/memory-allocators>mtrebi/memory-allocators</a></li></ul></div></article><hr><div class=post-info></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://github.com/muit rel=noopener>Miguel Fernandez Arce</a></span>
<span><a href=https://muit.xyz/drafts/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span><a href=https://github.com/piperift>Piperift</a></span></div></div></footer></div><script type=text/javascript src=/drafts/bundle.min.73c7c714cf43f7ae79f853c64ef05a1697c65bea136f1f8b34951a913a9c586631efbfd5bd0f3b9dd71d0f79839fa6983fb87b4d4a8d209e3c174c41c0367f7b.js integrity="sha512-c8fHFM9D9655+FPGTvBaFpfGW+oTbx+LNJUakTqcWGYx77/VvQ87ndcdD3mDn6aYP7h7TUqNIJ48F0xBwDZ/ew=="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D66MJWXCKK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D66MJWXCKK",{anonymize_ip:!1})}</script><script>window.netlifyIdentity&&window.netlifyIdentity.on("init",e=>{e||window.netlifyIdentity.on("login",()=>{document.location.href="/admin/"})})</script></body></html>