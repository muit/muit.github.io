<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Let’s talk about a different approach to ECS I have been rumbling about lately. Well, specifically, about how we query entities, manage dependencies and access/modify data.
What is ECS you ask? Fair question! ECS (as Entity-Component-System) is an architectural pattern based on DOD (data-oriented design), where you have three main elements:
Entities: They are just an identifier and don’t hold any data. Components: Structs of data associated with a single entity (1 entity can have 1 component of each type)."><meta name=keywords content="muitxer,homepage,blog,portfolio,unreal engine,C++,Rust,piperift"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://muit.xyz/drafts/posts/ecs-new-approach-to-ecs-apis/><title>A new approach to ECS APIs :: Miguel Fernandez Arce</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/drafts/main.css><meta itemprop=name content="A new approach to ECS APIs"><meta itemprop=description content="Let’s talk about a different approach to ECS I have been rumbling about lately. Well, specifically, about how we query entities, manage dependencies and access/modify data.
What is ECS you ask? Fair question! ECS (as Entity-Component-System) is an architectural pattern based on DOD (data-oriented design), where you have three main elements:
Entities: They are just an identifier and don’t hold any data. Components: Structs of data associated with a single entity (1 entity can have 1 component of each type)."><meta itemprop=datePublished content="2022-02-10T00:00:00+00:00"><meta itemprop=dateModified content="2022-02-10T00:00:00+00:00"><meta itemprop=wordCount content="1860"><meta itemprop=image content="https://muit.xyz/drafts"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://muit.xyz/drafts"><meta name=twitter:title content="A new approach to ECS APIs"><meta name=twitter:description content="Let’s talk about a different approach to ECS I have been rumbling about lately. Well, specifically, about how we query entities, manage dependencies and access/modify data.
What is ECS you ask? Fair question! ECS (as Entity-Component-System) is an architectural pattern based on DOD (data-oriented design), where you have three main elements:
Entities: They are just an identifier and don’t hold any data. Components: Structs of data associated with a single entity (1 entity can have 1 component of each type)."><meta property="og:title" content="A new approach to ECS APIs"><meta property="og:description" content="Let’s talk about a different approach to ECS I have been rumbling about lately. Well, specifically, about how we query entities, manage dependencies and access/modify data.
What is ECS you ask? Fair question! ECS (as Entity-Component-System) is an architectural pattern based on DOD (data-oriented design), where you have three main elements:
Entities: They are just an identifier and don’t hold any data. Components: Structs of data associated with a single entity (1 entity can have 1 component of each type)."><meta property="og:type" content="article"><meta property="og:url" content="https://muit.xyz/drafts/posts/ecs-new-approach-to-ecs-apis/"><meta property="og:image" content="https://muit.xyz/drafts"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2022-02-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-10T00:00:00+00:00"><meta property="article:published_time" content="2022-02-10 00:00:00 +0000 UTC"><script src=https://identity.netlify.com/v1/netlify-identity-widget.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>Miguel Fernandez Arce</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/drafts/pages/about>About</a></li><li><a href=/drafts/posts>Posts</a></li><li><a href=https://github.com/muit>GitHub</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://muit.xyz/drafts/posts/ecs-new-approach-to-ecs-apis/>A new approach to ECS APIs</a></h2><figure class=post-cover><img src=https://muit.xyz/Assets/Img/Covers/patterns.png alt="A new approach to ECS APIs"></figure><div class=post-content><p>Let’s talk about a different approach to ECS I have been rumbling about lately. Well, specifically, about how we query entities, manage dependencies and access/modify data.</p><h1 id=what-is-ecs-you-ask>What is ECS you ask?</h1><p>Fair question! <strong>ECS</strong> (as Entity-Component-System) is an architectural pattern based on DOD (data-oriented design), where you have three main elements:</p><ul><li><strong>Entities</strong>: They are just an identifier and don’t hold any data.</li><li><strong>Components</strong>: Structs of data associated with a single entity (1 entity can have 1 component of each type). They don’t have any code/logic.</li><li><strong>Systems</strong>: Functions executed operating entities and components.</li></ul><p>I could explain ECS in greater detail, but there are plenty of resources online already that will do a better job than me.
<a href="https://www.youtube.com/watch?v=0_Byw9UMn9g">This talk</a> is a good start, and for more resources, you can also
<a href=https://github.com/SanderMertens/ecs-faq>read this</a>.</p><p>I personally also like to consider <strong>Utilities</strong> as the forth secret child of ECS.
Utilities are functions that can be reused between systems. Any code that is not part of a system is a utility. One example could be <em>hierarchy</em> where we can <em>add, remove, or transfer children from entities</em> from multiple systems.</p><h1 id=current-approach-to-ecs-apis>Current approach to ECS APIs</h1><p>Now that we know what ECS is and the basics of how it works, let&rsquo;s talk about how we could improve it.</p><p>In most ECS libraries I have used so far, there is always the concept of a <strong>view</strong>, or a <strong>filter</strong>.
This is a tool that allows fast iteration of entities following a set of conditions. You can say, for example, &ldquo;iterate all entities with &lsquo;Player&rsquo; and &lsquo;Movement&rsquo; components, but ignore those with &lsquo;Frozen&rsquo; component&rdquo;.</p><p>Implementation details may differ, but I will be using using the popular library <strong>entt</strong> as an example (it&rsquo;s great, check it out). In this library, a “view” caches pools from the world when it is created, and uses them to check for entities matching some included and excluded components.</p><h3 id=problems-sharing-code>Problems sharing code</h3><p>So lets make an example with <strong>entt</strong> where we move agents (a system):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MoveAgents</span>(entt<span style=color:#f92672>::</span>registry<span style=color:#f92672>&amp;</span> registry, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We create a view matching all agents with movement and transform components
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>auto</span> view <span style=color:#f92672>=</span> registry.view<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Agent, <span style=color:#66d9ef>const</span> Movement, Transform<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We iterate all entities in the view
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(Id entity : view)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// We get components and apply position based on velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> movement <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> transform <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>		transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, so far, we are just fine.
But what if we have props that can move? But only when they are enabled.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MoveProps</span>(entt<span style=color:#f92672>::</span>registry<span style=color:#f92672>&amp;</span> registry, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> view <span style=color:#f92672>=</span> registry.view<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Prop, <span style=color:#66d9ef>const</span> Movement, Transform<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(Id entity : view)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> prop <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Prop<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (prop.isEnabled)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Can we reuse this?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> movement <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> transform <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>			transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Well, we get some duplicated code, we could export this into a utility. But how?</p><p>If we wanted to share code as utilities, we would be extremely limited, specially if we want to track which data we are reading and writing, which is crucial for scheduling (more on that later).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// We could use references, but it&#39;s not very practical since we need to get the components outside anyway
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ApplyMovement</span>(<span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&amp;</span> movement, Transform<span style=color:#f92672>&amp;</span> transform, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We could pass the registry, but then we lose the fast access to pools from views.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Also, we do not know from outside which components we are reading and writing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ApplyMovement</span>(entt<span style=color:#f92672>::</span>registry<span style=color:#f92672>&amp;</span> registry, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> movement <span style=color:#f92672>=</span> registry.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&gt;</span>(entity); <span style=color:#75715e>// Accessing component directly through world is slow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> transform <span style=color:#f92672>=</span> registry.get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>	transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We could pass the view as a template parameter.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// But templates need to be declared where they are used, meaning all shared functions will need to be most likely on a header.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// To that, you add different views for the same function, and you get slower compile times.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Outside of templates, Views also are not intended to control access, and they can not do all the things you can do with the world.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> View<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ApplyMovement(View view, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> movement <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> transform <span style=color:#f92672>=</span> view.get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>	transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Along with the problems sharing code (utilities) between systems, you will also have a really hard time tracking dependencies as your project grows if you want to do any sort of scheduling.</p><h3 id=problems-scheduling>Problems scheduling</h3><p>As I mentioned in the previous step, scheduling is a huge problem, and we should simplify it.</p><p>Scheduling helps us organize hundreds of system functions to execute safely in multithreading. To achieve that, we need to know where we read and modify components:</p><ul><li>We can safely <strong>read</strong> components of the same type from many threads at the same time.</li><li>We can&rsquo;t safely <strong>read</strong> components of the same type <strong>while</strong> any other thread is <strong>writing</strong> them.</li></ul><p>We can, of course, schedule by hand, but this quickly becomes unmaintainable. That&rsquo;s why there are many ways to automate it. But, as I said, you need to be able to know what you are doing inside a function from outside, or this won&rsquo;t be possible.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// If we pass around the registry, we don&#39;t know our dependencies
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We don&#39;t know which components this function is accessing and modifying
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MoveProps</span>(entt<span style=color:#f92672>::</span>registry<span style=color:#f92672>&amp;</span> registry, <span style=color:#66d9ef>float</span> deltaTime) {}
</span></span></code></pre></div><h3 id=problems-controlling-data-flow>Problems controlling data-flow</h3><p>One of the points of DOD is that all code serves a single purpose: It converts data (input) into other data (output). “It&rsquo;s all about the data.”</p><p>Having a view that we mostly only iterate is limiting us if we want to do proper algorithms where we use multiple steps to (efficiently) operate data.</p><h1 id=fixing-the-problems>Fixing the problems</h1><p>Lets see what we need:</p><ul><li>We need to be able to <strong>easily</strong> share code</li><li>We need to express dependencies when reading and writing components, allowing us to schedule</li><li>We need to be able to apply complex data flows, allowing more cache and cpu friendly code</li><li>It has to be blazing fast</li><li>Errors must be <strong>simple</strong> and straight forward <em>&mldr;proceeds to look at templates with disapproval</em></li></ul><p>I experimented with a solution to this for a while and ended up implementing it in
<a href=https://github.com/PipeRift/rift><strong>Rift</strong></a>.
This solution I came up with solves all the points above, so let&rsquo;s have a look rebuilding the previous examples with it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// We pass an Access with the types we can write, and those we can only read (const)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MoveProps</span>(TAccess<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Prop, <span style=color:#66d9ef>const</span> Movement, Transform<span style=color:#f92672>&gt;</span> access, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(Id entity : ListAll<span style=color:#f92672>&lt;</span>Prop, Movement, Transform<span style=color:#f92672>&gt;</span>(access))
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> prop <span style=color:#f92672>=</span> access.Get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Prop<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (prop.isEnabled)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Can we reuse this? Yes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>//const auto&amp; movement = access.Get&lt;const Movement&gt;(entity);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>//auto&amp; transform = access.Get&lt;Transform&gt;(entity);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>//transform.position += movement.velocity * deltaTime;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// So, lets reuse it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			ApplyMovement(access, entity, deltaTime);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The parent access (MoveProps) must have these components.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If it doesn&#39;t, we will get proper errors telling us what&#39;s missing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ApplyMovement</span>(TAccess<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement, Transform<span style=color:#f92672>&gt;</span> access, Id entity, <span style=color:#66d9ef>float</span> deltaTime)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> movement <span style=color:#f92672>=</span> access.Get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Movement<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> transform <span style=color:#f92672>=</span> access.Get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>(entity);
</span></span><span style=display:flex><span>	transform.position <span style=color:#f92672>+=</span> movement.velocity <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=access>Access</h3><p>A access represents a set of components for efficient access and dependency tracking. It also can’t be directly iterated (by design). We have other tools for that.</p><ul><li>It is very cheap to copy (only a pool pointer copy for each component type)</li><li>It provides instant access into component pools</li><li>Extremely simpler and less template-heavy than views</li><li>Can be constructed implicitly from the ECS world or other bigger accesses.</li></ul><p>Access can have two flavors. Compile-time assisted <code>TAccess&lt;Types></code> or runtime based <code>Access</code></p><p>It also makes sense to pass them as const reference to functions. They are cheap to copy yes, but we might not need to do it at all. That&rsquo;s why I added an alias <code>TAccessRef&lt;Types></code> which is essentially the same as <code>const TAccess&lt;Types>&</code>. It&rsquo;s just easier to write.</p><h3 id=filtering-entities>Filtering entities</h3><p>If a access can&rsquo;t iterate on its own, how do we do it?</p><p>Iteration is done by creating and modifying lists of ids:</p><ul><li><code>ListAll&lt;Types>(access)</code>: Returns all entity ids containing all the provided components.</li><li><code>ListAny&lt;Types>(access)</code>: Returns all entity ids containing at least one of the provided components</li></ul><p>Then we can also apply new filters like excluding components:</p><ul><li><code>RemoveIf&lt;Types>(access, ids)</code>: Exclude entities not having a component</li><li><code>RemoveIfNot&lt;Types>(access, ids)</code>: Exclude entities having a component</li></ul><p>It should be mentioned that these functions don&rsquo;t ensure the order is kept by default (for performance), but we can use their counterparts for that:</p><ul><li><code>RemoveIfStable&lt;Types>(access, ids)</code>: Exclude entities not having a component</li><li><code>RemoveIfNotStable&lt;Types>(access, ids)</code>: Exclude entities having a component</li></ul><p>The potential of this is that we are just operating a list of indexes, and we are not limited by the functions above on what we can do. Its just &ldquo;filtering&rdquo; lists of ids.</p><p>One example could be in
<a href=https://github.com/PipeRift/rift>Rift</a>, where the compiler precaches two lists, one for classes and one for structs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>TArray<span style=color:#f92672>&lt;</span>AST<span style=color:#f92672>::</span>Id<span style=color:#f92672>&gt;</span> classes, structs;
</span></span><span style=display:flex><span>AST<span style=color:#f92672>::</span>Hierarchy<span style=color:#f92672>::</span>GetChildren(ast, moduleId, classes);
</span></span><span style=display:flex><span>AST<span style=color:#f92672>::</span>RemoveIfNot<span style=color:#f92672>&lt;</span>CType<span style=color:#f92672>&gt;</span>(ast, classes);
</span></span><span style=display:flex><span>structs <span style=color:#f92672>=</span> classes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AST<span style=color:#f92672>::</span>RemoveIfNot<span style=color:#f92672>&lt;</span>CClassDecl<span style=color:#f92672>&gt;</span>(ast, classes);
</span></span><span style=display:flex><span>AST<span style=color:#f92672>::</span>RemoveIfNot<span style=color:#f92672>&lt;</span>CStructDecl<span style=color:#f92672>&gt;</span>(ast, structs);
</span></span></code></pre></div><p>As you can see, it is filtering different components to finish with those two lists of types.</p><p>It also shows how filtering can also be done directly from the world (ast in the example) without an access. You wont get the benefit of cached pools, but it will still be really fast to iterate:<br><code>ListAll&lt;Types>(world)</code> <code>RemoveIf&lt;Types>(world, ids)</code> <code>RemoveIfNot&lt;Types>(world, ids)</code></p><h2 id=performance>Performance</h2><p>I mentioned many reasons why this style of API is attractive, but there is another one. It is fast.</p><p>When I implemented accesses for
<a href=https://github.com/PipeRift/rift><strong>Rift</strong></a>, I already had filters (very similar to entt’s views). So I took the chance to do a one to one comparison with the following results:</p><p>In <strong>debug</strong> access filtering gets up to 3 times faster iterating than views.</p><p><img src=/Assets/Img/ecs-access-debug.png alt="Access in Debug"></p><p>While in <strong>release</strong> the difference is tighter, between 35% to 50% faster in most runs.</p><p><img src=/Assets/Img/ecs-access-release.png alt="Access in Release"></p><p>Should be noted that this benchmark runs an empty iteration loop. For views, this means their pool checks are very close in execution. In other words, it is their <strong>ideal scenario</strong>. It is unrealistically in their favor. However, they seem to run slower. Why is that?</p><h3 id=why-is-it-faster>Why is it faster?</h3><p>Unlike views, accesses don&rsquo;t need to find their pools, again and again, every time they get created. Most of the time, a access is created from another, which is literally just copying the relevant pool pointers.</p><p>However this is not where most of the performance benefit comes from.</p><p>It comes from the fact that, while in views, each entity is checked at once against all the pools to filter, with <strong>ListAll</strong> all ids are checked pool after pool:</p><p><strong>Views</strong></p><ul><li>Iterate all ids in smallest pool<ul><li>Check that the id has components A, B, C</li></ul></li></ul><p><strong>Access Filtering</strong></p><ul><li>Get all ids from smallest pool</li><li>Remove those that don&rsquo;t have component A</li><li>Remove those that don&rsquo;t have component B</li><li>Remove those that don&rsquo;t have component C</li></ul><p>This uses a single pool and its hash-set at a time, making it more cache-friendly.</p><br><p>I hope this post was not too dense. It is quite a specific topic, after all.</p><p>Consider having a look at
<a href=https://github.com/PipeRift/rift><strong>Rift</strong></a>. It would be incredibly helpful to get your ideas, feedback and/or code contributions!</p></div></article><hr><div class=post-info></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://github.com/muit rel=noopener>Miguel Fernandez Arce</a></span>
<span><a href=https://muit.xyz/drafts/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span><a href=https://github.com/piperift>Piperift</a></span></div></div></footer></div><script type=text/javascript src=/drafts/bundle.min.73c7c714cf43f7ae79f853c64ef05a1697c65bea136f1f8b34951a913a9c586631efbfd5bd0f3b9dd71d0f79839fa6983fb87b4d4a8d209e3c174c41c0367f7b.js integrity="sha512-c8fHFM9D9655+FPGTvBaFpfGW+oTbx+LNJUakTqcWGYx77/VvQ87ndcdD3mDn6aYP7h7TUqNIJ48F0xBwDZ/ew=="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D66MJWXCKK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D66MJWXCKK",{anonymize_ip:!1})}</script><script>window.netlifyIdentity&&window.netlifyIdentity.on("init",e=>{e||window.netlifyIdentity.on("login",()=>{document.location.href="/admin/"})})</script></body></html>